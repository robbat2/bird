/*
 *	BIRD -- Multi-Threaded Routing Toolkit (MRT) Routing Information Export Format Tests
 *
 *	(c) 2015 CZ.NIC z.s.p.o.
 *
 *	Can be freely distributed and used under the terms of the GNU GPL.
 */

#include "test/birdtest.h"
#include "test/birdtest_support.h" /* REMOVE ME */
#include "nest/mrtdump.h"
#include "nest/mrtdump.c" /* REMOVE ME */

static void
show_mrt_msg(struct mrt_buffer *msg)
{
  uint i;
  bt_debug("show_mrt_msg: \n  ");
  for (i = 0; i < msg->msg_length; i++)
  {
    if (i && (i % 16) == 0)
      bt_debug("\n  ");
    bt_debug("%02X ", msg->msg[i]);
  }
  bt_debug("\n");
}

static void
compare(const byte *expected, const byte *data, u32 length)
{
  u32 i;
  for(i = 0; i < length; i++)
    bt_assert_msg(expected[i] == data[i], "Different at %d, 0x%02X != 0x%02X", i, expected[i], data[i]);
}

static int
t_peer_index_table(void)
{
  resource_init();

  struct mrt_peer_index_table pit_msg;

  u32 collector_bgp_id = 0x12345678;
  const char *collector_name = "test";
  mrt_peer_index_table_init(&pit_msg, collector_bgp_id, collector_name);

  u32 i;
  for (i = 0; i < 5; i++)
  {
    ip_addr addr;
#ifdef IPV6
    ip6_pton("1234:5678::9abc:def0", &addr);
#else
    ip4_pton("12.34.56.78", &addr);
#endif
    mrt_peer_index_table_add_peer(&pit_msg, i | 0x30303030, &addr, i | 0x08080808);
  }

  show_mrt_msg(&pit_msg.msg);

  const byte expected[] = {
      /* Reserve for the main MRT Header */
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      /* PEER_INDEX_TABLE Header */
      0x78, 0x56, 0x34, 0x12,   0x04, 0x00,   0x74, 0x65, 0x73, 0x74,   0x00, 0x05,
      /* Peer Entries */
#ifdef IPV6
      0x03,   0x30, 0x30, 0x30, 0x30,   0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xDE, 0xBC, 0x9A,   0x08, 0x08, 0x08, 0x08,
      0x03,   0x31, 0x30, 0x30, 0x30,   0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xDE, 0xBC, 0x9A,   0x09, 0x08, 0x08, 0x08,
      0x03,   0x32, 0x30, 0x30, 0x30,   0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xDE, 0xBC, 0x9A,   0x0A, 0x08, 0x08, 0x08,
      0x03,   0x33, 0x30, 0x30, 0x30,   0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xDE, 0xBC, 0x9A,   0x0B, 0x08, 0x08, 0x08,
      0x03,   0x34, 0x30, 0x30, 0x30,   0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xDE, 0xBC, 0x9A,   0x0C, 0x08, 0x08, 0x08,
#else
      0x02,   0x30, 0x30, 0x30, 0x30,   0x4E, 0x38, 0x22, 0x0C,   0x08, 0x08, 0x08, 0x08,
      0x02,   0x31, 0x30, 0x30, 0x30,   0x4E, 0x38, 0x22, 0x0C,   0x09, 0x08, 0x08, 0x08,
      0x02,   0x32, 0x30, 0x30, 0x30,   0x4E, 0x38, 0x22, 0x0C,   0x0A, 0x08, 0x08, 0x08,
      0x02,   0x33, 0x30, 0x30, 0x30,   0x4E, 0x38, 0x22, 0x0C,   0x0B, 0x08, 0x08, 0x08,
      0x02,   0x34, 0x30, 0x30, 0x30,   0x4E, 0x38, 0x22, 0x0C,   0x0C, 0x08, 0x08, 0x08,
#endif
  };

  bt_assert(pit_msg.msg.msg_length == sizeof(expected));
  compare(expected, pit_msg.msg.msg, sizeof(expected));

  mrt_msg_free(&pit_msg.msg);
  return BT_SUCCESS;
}

static int
t_rib_table(void)
{
  resource_init();

  struct mrt_rib_table rt_msg;
  u32 sequence_number = 0x12345678;
  u8 prefix_len = 24;
  ip_addr prefix;
#ifdef IPV6
  ip6_pton("1234:5678::9abc:def0", &prefix);
#else
  ip4_pton("12.34.56.78", &prefix);
#endif
  mrt_rib_table_init(&rt_msg, sequence_number, prefix_len, &prefix);

  u32 i;
  for(i = 0; i < 5; i++)
  {
    struct mrt_rib_entry entry = {
	.peer_index =      i,
	.originated_time = i | 0x08080808,
	.attributes_length = 7,
	.attributes = "abcdefg",
    };
    mrt_rib_table_add_entry(&rt_msg, &entry);
  }

  show_mrt_msg(&rt_msg.msg);

  const byte expected[] = {
      /* Reserve for the main MRT Header */
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      /* AFI/SAFI-Specific RIB Table Header */
#ifdef IPV6
      0x78, 0x56, 0x34, 0x12,   0x18, 0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xDE, 0xBC, 0x9A,   0x00, 0x05,
#else
      0x78, 0x56, 0x34, 0x12,   0x18,   0x4E, 0x38, 0x22, 0x0C,   0x00, 0x05,
#endif
      /* RIB Entries */
      0x00, 0x00,   0x08, 0x08, 0x08, 0x08,   0x07, 0x00,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x01, 0x00,   0x09, 0x08, 0x08, 0x08,   0x07, 0x00,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x02, 0x00,   0x0A, 0x08, 0x08, 0x08,   0x07, 0x00,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x03, 0x00,   0x0B, 0x08, 0x08, 0x08,   0x07, 0x00,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x04, 0x00,   0x0C, 0x08, 0x08, 0x08,   0x07, 0x00,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  };

  bt_assert(rt_msg.msg.msg_length == sizeof(expected));
  compare(expected, rt_msg.msg.msg, sizeof(expected));

  mrt_msg_free(&rt_msg.msg);
  return BT_SUCCESS;
}

int
main(int argc, char *argv[])
{
  bt_init(argc, argv);

  bt_test_suite(t_peer_index_table, 	"TABLE_DUMP_V2: Peer index table");
  bt_test_suite(t_rib_table, 		"TABLE_DUMP_V2: RIB table");

  return bt_end();
}
